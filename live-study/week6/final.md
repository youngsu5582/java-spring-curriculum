
Final 키워드는 변수 , 메소드 , 클래스에 사용될 수 있다

### Final 변수

해당 변수는 수정이 될 수 없다
-> 수정이 될 수 없으므로 , 초기화는 필수

객체 안 변수라면
생성자 , static block 으로 생성까지 허용

객체 내부의 값은 변경 가능하나 , 가리키는 객체 변경은 불가능

-> Primitive 값은 내부에 값을 가지고 , Reference 값은 객체의 주소를 가진다

즉 , 객체 내부의 값은 영향 받지 않으므로 변경 불가능 ( 배열 도 내부 )

변수를 final 로 선언하면 초기화 전 사용하면 컴파일 에러 발생

### Final 메소드

메소드에 final 붙히면 override 제한

즉 , 해당 메소드를 수정해서 사용하지 못하도록 제한 가능

### Final 클래스

클래스에 final 붙히면 상속 불가능

즉 , 다른 클래스에서 상속해 재정의 불가능

재정의 여부를 생각해 불가능하게 하고 싶을시 사용


### 장점

#### 컴파일러 최적화

final 키워드는 컴파일러에게 특정 변수 , 메소드가 변하지 않는 정보를 제공해줌
-> 최적화 가능

##### 메서드 인라인화

final 키워드를 사용해 해당 메서드가 하위 클래스에서 오버라이드 안되는 것을 보장
-> 메소드 호출을 메소드 본문으로 대체 가능
=> 메소드 호출 오버헤드 줄이고 , 실행 속도 높이는데 기여

##### 상수 폴딩

final 로 선언된 상수 변수 값을 컴파일 시점에 알 수 있다
-> 컴파일 시간에 해당 상수 값을 사용하는 코드로 대체
=> 실행 시간에 변수 계산하는 대신 , 미리 계산된 값 사용해 프로그램 실행 속도 향상

#### 불변 객체

##### Thread-safe

변하지 않으므로 , Thread Safe 하므로 병렬 프로그래밍에 유용
-> 동기화 고려 X 해도 됨 ( 항상 같은 값 반환 , 쓰기 연산 불가능 하므로)

##### 실패 원자적 메소드

말이 어려우나 , 즉 예외나 실패해도 상관이 없는 메소드

가변 객체일 시 , 작업 도중 예외 발생하면 해당 객체가 불완전한 상태에 빠질수 있음 ( 상태 변하기에 )
불변 객체는 어떤 예외가 발생하더라도 , 정해진 로직 + 동일 상태 유지하므로 추가적인 에러 방지
##### Cache , Map , Set 같은 자료구조 적합

원소가 가변 객체라 변경되면 , 갱신 작업이 필요
-> 불변 객체라면 데이터가 저장된 이후 부가 작업 고려 X
##### 예측 가능 , 안전하게 사용 가능

협업을 하더라도 , 상태 와 결과를 보장하므로 불필요한 시간 절약 가능

##### GC 성능 향상 가능

final 객체를 참조하는 컨테이너 객체 ( 다수 객체를 담고 있는 객체 )
-> 불변 객체가 , 컨테이너 객체보다 먼저 생성되므로 더 젊음
( 하위 불변 객체들에 대한 검사는 skip )
=> GC 오버헤드 감소 및 성능 향상
### 불변 클래스 규칙

- 클래스를 final로 선언하라
- 모든 클래스 변수를 private과 final로 선언하라
- 객체를 생성하기 위한 생성자 또는 정적 팩토리 메서드를 추가하라
- 참조에 의해 변경가능성이 있는 경우 방어적 복사를 이용하여 전달하라

근데 , 불변 클래스 까지는 애매할 요소가 있는듯